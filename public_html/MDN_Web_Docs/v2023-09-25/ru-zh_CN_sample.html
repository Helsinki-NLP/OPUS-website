<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd"> 
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
</head>
<body>
<p>

# ru/games/anatomy/index.xml.gz<br>
# zh_CN/games/anatomy/index.xml.gz

<p><hr>
(src)="1"> { { GamesSidebar } } <br>
(trg)="1"> { { GamesSidebar } } <br>
<hr>
(src)="5"> Показать , получить , преобразовать , вычислить , повторить <br>
(trg)="2"> 本文 从 技术 角度 分析 了 一般 电子 游戏 的 结构 和 工作 流程 ， 就此 介绍 主 循环 是 如何 运行 的 。 <br>
<hr>
(src)="8"> Не удивительно , что данный шаблон соответствует тому как программируется игровая логика ( движок ) . <br>
(trg)="3"> 它 有助 于 初学者 了解 在 现代 游戏 开发 领域 构 建 游戏 时 需要 什么 ， 以及 如何 将 JavaScript 这样 的 Web 标准 工具 作为 自己 的 工具 使用 。 <br>
<hr>
(src)="9"> Особенности игр . <br>
(trg)="4"> 游戏 开发 经验 丰富 但 不 熟悉 Web 开发 的 开发 者 也能 从中 受益 。 <br>
<hr>
(src)="17"> Эта покадровая модель реализована в так называемом основном цикле . <br>
(trg)="5"> 呈现 、 接收 、 解释 、 计算 、 重复 <br>
<hr>
(src)="20"> Ваш игровой цикл может быть похож на пример поиска отличий и основан на входных событиях . <br>
(src)="21"> Это может потребовать как ввода , так и симуляции времени . <br>
(trg)="6"> 所有电子游戏的目标都是向用户 呈现 一个场景 ， 接收 他们的输入 ， 将这些输入信号 解释 为动作 ， 并 计算 出 由 这些 动作 产生 的 新 场景 。 <br>
<hr>
(src)="24"> Конечно , ваша игра будет оптимизирована настолько , насколько вы её сделаете . <br>
(trg)="7"> 游戏 不断地 循环 遍 历 ， 一遍 又 一遍 ， 直到 遇到 某些 终止 条件 （ 比如 赢 、 输 或者 退出 睡觉 ） 。 <br>
<hr>
(src)="26"> Построение основного цикла в JavaScript <br>
(trg)="8"> 毫不 奇怪 ， 这种 模式 与 游戏 引擎 的 编 程 方式 相 呼应 。 <br>
<hr>
(src)="33"> Так же , вероятно , это облегчит вам работу . <br>
(trg)="9"> 具体 情况 取决 于 游戏 本身 。 <br>
<hr>
(src)="38"> Вот пример простого основного цикла : <br>
(trg)="10"> 一些游戏通过 用户 输入 来 驱动 这个 循环 。 <br>
<hr>
(src)="45"> Это не случайно и считает лучшей практикой . <br>
(trg)="11"> 想象 一下 ， 你 正在 开发 一种 “ 大家 来 找 茬 ” 类型 的 游戏 。 <br>
<hr>
(src)="46"> Ранний вызов следующего requestAnimationFrame гарантирует , что браузер получит его вовремя , чтобы спланировать соответствующим образом , даже если ваш текущий кадр пропустит своё окно VSync . <br>
(trg)="12"> 这些游戏向用户 呈现 两张图片 ， 游戏 接收 点击 （ 或触摸 ） ； 将用户输入 解释 为 成功 ， 失败 ， 暂停 ， 菜单 交互 等 。 <br>
<hr>
(src)="47"> Приведённый выше фрагмент кода содержит два оператора . <br>
(trg)="13"> 最后 ， 游戏根据用户的输入 计算 并 更新 游戏 场景 。 <br>
<hr>
(src)="48"> Первый оператор создаёт функцию как глобальную переменную с именем main ( ) . <br>
(trg)="14"> 这种 游戏 是 由 用户 的 输入 驱动 ， 也就是说 ， 它 会 在 用户 进行 输入 之后 冻结 画面 ， 等待 玩家 进行 新的 输入 。 <br>
<hr>
(src)="50"> Второй оператор вызывает функцию main ( ) , описанную в первом операторе . <br>
(trg)="15"> 这 是 一种 基于 回 合 的 游戏 类型 ， 它 不需要 每 帧 持续 更新 画面 ， 只有 当 玩家 作出 反应 时 才 会 。 <br>
<hr>
(src)="55"> Вам предоставляется контроль над каждым кадром анимации . <br>
(trg)="16"> 另 一些 游戏 需要 尽可能 控制 每 一个 细 微 的 时间 片 （ 动画 ） 。 <br>
<hr>
(src)="56"> Это также очень просто , потому что main ( ) - единственная функция , которая зацикливается . <br>
(trg)="17"> 与 上述 原理 有点 小 区别 ： 每 个 动画 帧 都 将 循环 遍 历 ， 并 在 之后 第 一个 可用 的 轮 次 捕获 玩家 输入 的 任何 变化 。 <br>
<hr>
(src)="61"> Их очень много и они сделают вашу жизнь проще . <br>
(trg)="18"> 这种每帧一次的模型是通过一个叫 主 循环 的 东西 实现 的 。 <br>
<hr>
(src)="62"> Создание улучшенного основного цикла в JavaScript <br>
(trg)="19"> 如果 你的 游戏 循环 是 基于 时间 的 ， 则 必须 保证 对 主 循环 精准 的 模拟 。 <br>
<hr>
(src)="68"> Браузер может случайно решить , <br>
(trg)="20"> 但 它 也 可能 不需要 逐 帧 控制 。 <br>
<hr>
(src)="69"> * что весь этот код начинается с предыдущей строки . <br>
(trg)="21"> 你的 游戏 循环 可能 类似 找 不同 的 例子 ， 并 以 输入 事件 作为 基础 。 <br>
<hr>
(src)="74"> function main ( ) { <br>
(src)="75"> window . requestAnimationFrame ( main ) ; <br>
(trg)="22"> 它 可能 需要 输入 和 模拟 时间 片 。 <br>
<hr>
(src)="77"> } <br>
(src)="78"> main ( ) ; / / Вызов цикла <br>
(src)="79"> } ) ( ) ; <br>
(trg)="23"> 它 甚至 可以 基于 其他 的 东西 来 循环 。 <br>
<hr>
(src)="84"> Необходимо передать в cancelAnimationFrame ( ) идентификатор последнего вызова requestAnimationFrame ( ) . <br>
(trg)="24"> 现代 JavaScript - 正如 下 一节 中 所 描述 的 - 它 可以 轻松 开发 出 一个 高效 的 ， 逐 帧 执行 的 主 循环 ， 这 很 值得 庆幸 。 <br>
<hr>
(src)="89"> * полагается на автоматическую вставку точки с запятой ( ASI ) . <br>
(trg)="25"> 当然 ， 你的 游戏 只 会 按照 你 所 做的 那样 优 化 。 <br>
<hr>
(src)="90"> Браузер может случайно решить , <br>
(src)="91"> * что весь этот код начинается с предыдущей строки . <br>
(src)="92"> Первая точка с запятой отмечает начало <br>
(trg)="26"> 如果 某些 东西 看起来 应该 被 添加 到 一个 更 罕见 的 事件 里 ， 那么 将 它 从 主 循环 中 剥离 出来 通常 是 个 好主意 （ 但 并非 总是 如此 ） 。 <br>
<hr>
(src)="101"> } <br>
(src)="102"> main ( ) ; / / Вызов цикла <br>
(src)="103"> } ) ( ) ; <br>
(trg)="27"> 在 JavaScript 中 构 建 一个 主 循环 <br>
<hr>
(src)="106"> window . cancelAnimationFrame ( MyGame . stopMain ) ; <br>
(trg)="28"> JavaScript 能 很好 的 处理 事件 和 回 调 函数 。 <br>
<hr>
(src)="116"> Браузер решает , как связать эти запросы с их основным циклом . <br>
(trg)="29"> 现代 浏览 器 努力 在 需要 的 时候 调 用 方法 ， 并 在 间隙 中 闲下来 （ 或 做 其他 任务 ） 。 <br>
<hr>
</body>
</html>
