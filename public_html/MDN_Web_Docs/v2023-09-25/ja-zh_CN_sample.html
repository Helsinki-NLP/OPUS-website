<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
"http://www.w3.org/TR/REC-html40/loose.dtd"> 
<html>
<head>
<title>Untitled Document</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
</head>
<body>
<p>

# ja/games/anatomy/index.xml.gz<br>
# zh_CN/games/anatomy/index.xml.gz

<p><hr>
(src)="1"> { { GamesSidebar } } <br>
(trg)="1"> { { GamesSidebar } } <br>
<hr>
(src)="2"> この 記事 では 平均 的 な ビデオ ゲーム の 中身 と ワーク フロー を 技術 的 な 観点 、 メイン ループ が どう 動く べ き か に関して 見 てい き ます 。 <br>
(trg)="2"> 本文 从 技术 角度 分析 了 一般 电子 游戏 的 结构 和 工作 流程 ， 就此 介绍 主 循环 是 如何 运行 的 。 <br>
<hr>
(src)="3"> 初心者 が 現代 的 な ゲーム 開発 の 海 で 、 ゲーム 制作 に 何 が 必要 な の か 、 JavaScript の よう な ウェブ 標準 が ツール として 寄与 し て いるか を 理解 する の に 役 立ち ます 。 <br>
(trg)="3"> 它 有助 于 初学者 了解 在 现代 游戏 开发 领域 构 建 游戏 时 需要 什么 ， 以及 如何 将 JavaScript 这样 的 Web 标准 工具 作为 自己 的 工具 使用 。 <br>
<hr>
(src)="4"> ベテラン の ゲーム プログラマー で ウェブ 開発 を 始め た ばかり の 方 に も 役 立ち ます 。 <br>
(trg)="4"> 游戏 开发 经验 丰富 但 不 熟悉 Web 开发 的 开发 者 也能 从中 受益 。 <br>
<hr>
(src)="5"> 表示 し 、 受け入れ 、 翻訳 し 、 計算 し 、 繰り返す <br>
(trg)="5"> 呈现 、 接收 、 解释 、 计算 、 重复 <br>
<hr>
(src)="6"> あらゆるビデオゲームのゴールはユーザーに状況を 表示 して入力を 受け入れ てこの信号を 翻訳 し て 行動し 、 行動から得られる新しい状況を 計算 する こと です 。 <br>
(trg)="6"> 所有电子游戏的目标都是向用户 呈现 一个场景 ， 接收 他们的输入 ， 将这些输入信号 解释 为动作 ， 并 计算 出 由 这些 动作 产生 的 新 场景 。 <br>
<hr>
(src)="7"> ゲーム は こうした 段階 を 常に 何 度 も 何 度 も 繰り返し て 、 何 か の 条件 が ( 例えば 勝利 や 敗退 や 、 あるいは 終了 し て 寝る こと ) 起きる まで 繰り返し ます 。 <br>
(trg)="7"> 游戏 不断地 循环 遍 历 ， 一遍 又 一遍 ， 直到 遇到 某些 终止 条件 （ 比如 赢 、 输 或者 退出 睡觉 ） 。 <br>
<hr>
(src)="8"> 驚く こと で なく 、 この パターン は ゲーム エンジン が プログラム さ れ て いる さま に 対応 し てい ます 。 <br>
(trg)="8"> 毫不 奇怪 ， 这种 模式 与 游戏 引擎 的 编 程 方式 相 呼应 。 <br>
<hr>
(src)="9"> 詳細 な 仕様 は ゲーム に 依存 し ます 。 <br>
(trg)="9"> 具体 情况 取决 于 游戏 本身 。 <br>
<hr>
(src)="12"> このゲームはユーザーに 2 つの画像を 表示 し ます 。 <br>
(trg)="10"> 一些游戏通过 用户 输入 来 驱动 这个 循环 。 <br>
<hr>
(src)="13"> ユーザーのクリック ( やタッチ ) を 受け入れ ます 。 <br>
(trg)="11"> 想象 一下 ， 你 正在 开发 一种 “ 大家 来 找 茬 ” 类型 的 游戏 。 <br>
<hr>
(src)="14"> 入力を成功 、 失敗 、 一時停止 、 メニューのやりとりなどに 翻訳 し ます 。 <br>
(trg)="12"> 这些游戏向用户 呈现 两张图片 ， 游戏 接收 点击 （ 或触摸 ） ； 将用户输入 解释 为 成功 ， 失败 ， 暂停 ， 菜单 交互 等 。 <br>
<hr>
(src)="15"> 最後にその入力から起きて更新されるシーンを 計算 し ます 。 <br>
(trg)="13"> 最后 ， 游戏根据用户的输入 计算 并 更新 游戏 场景 。 <br>
<hr>
(src)="16"> ゲーム ループ は ユーザー 入力 まで 進 んで 、 ユーザー が 与える まで スリープ し ます 。 <br>
(trg)="14"> 这种 游戏 是 由 用户 的 输入 驱动 ， 也就是说 ， 它 会 在 用户 进行 输入 之后 冻结 画面 ， 等待 玩家 进行 新的 输入 。 <br>
<hr>
(src)="17"> これ は 1 ターン ずつ の アプローチ 以上 の もの で 、 毎 フレーム ごと の 常時 更新 を 求め ず 、 プレイヤー が 反応 した 時 だけ 更新 し ます 。 <br>
(trg)="15"> 这 是 一种 基于 回 合 的 游戏 类型 ， 它 不需要 每 帧 持续 更新 画面 ， 只有 当 玩家 作出 反应 时 才 会 。 <br>
<hr>
(src)="18"> 他の ゲーム は なるべく 最小 な 個々 の タイム スライス 単位 を 管理 し ます 。 <br>
(trg)="16"> 另 一些 游戏 需要 尽可能 控制 每 一个 细 微 的 时间 片 （ 动画 ） 。 <br>
<hr>
(src)="19"> 上記 と 同じ 原則 が 少し ひねり を 加 えて 適用 さ れ ます 。 <br>
(trg)="17"> 与 上述 原理 有点 小 区别 ： 每 个 动画 帧 都 将 循环 遍 历 ， 并 在 之后 第 一个 可用 的 轮 次 捕获 玩家 输入 的 任何 变化 。 <br>
<hr>
(src)="20"> アニメーション の 各 フレーム は サイクル を 勧め 、 利用 できる 最初 の ターン で ユーザー 入力 の 変化 が 捉 え ら れ ます 。 <br>
(trg)="18"> 这种每帧一次的模型是通过一个叫 主 循环 的 东西 实现 的 。 <br>
<hr>
(src)="22"> ゲーム ループ が 時間 ベース ならば 、 これ は シミュレーション が 従う べ き 権威 です 。 <br>
(trg)="19"> 如果 你的 游戏 循环 是 基于 时间 的 ， 则 必须 保证 对 主 循环 精准 的 模拟 。 <br>
<hr>
(src)="23"> しかし 毎 フレーム の 管理 は 不要 かも し れ ま せん 。 <br>
(trg)="20"> 但 它 也 可能 不需要 逐 帧 控制 。 <br>
<hr>
(src)="24"> ゲーム ループ は 違い を 見つける 例 と 同じ で 入力 イベント に 依存 し て いるか もし れ ま せん 。 <br>
(trg)="21"> 你的 游戏 循环 可能 类似 找 不同 的 例子 ， 并 以 输入 事件 作为 基础 。 <br>
<hr>
(src)="25"> また 入力 と 時間 の シュミレーション の 両方 が 必要 かも し れ ま せん 。 <br>
(trg)="22"> 它 可能 需要 输入 和 模拟 时间 片 。 <br>
<hr>
(src)="26"> その他 の もの に 完全 に 依存 する ループ かも し れ ま せん 。 <br>
(trg)="23"> 它 甚至 可以 基于 其他 的 东西 来 循环 。 <br>
<hr>
(src)="27"> モダン JavaScript — 詳 しく は 次 の 節 で 述 べ ます が — は 効率 よく 、 毎 フレーム で 実行 さ れる メイン ループ を 簡単 に 開発 でき ます 。 <br>
(trg)="24"> 现代 JavaScript - 正如 下 一节 中 所 描述 的 - 它 可以 轻松 开发 出 一个 高效 的 ， 逐 帧 执行 的 主 循环 ， 这 很 值得 庆幸 。 <br>
<hr>
(src)="28"> もちろん 、 あなた の ゲーム では できるだけ 最適 化 でき ます 。 <br>
(trg)="25"> 当然 ， 你的 游戏 只 会 按照 你 所 做的 那样 优 化 。 <br>
<hr>
(src)="29"> あまり 発生 しない イベント に アタッチ すべ きだ と 思う ならば 、 メイン ループ から 外れる の も ( いつも では ない にし ろ ) 良い 考え です 。 <br>
(trg)="26"> 如果 某些 东西 看起来 应该 被 添加 到 一个 更 罕见 的 事件 里 ， 那么 将 它 从 主 循环 中 剥离 出来 通常 是 个 好主意 （ 但 并非 总是 如此 ） 。 <br>
<hr>
(src)="30"> JavaScript で メイン ループ を 作る <br>
(trg)="27"> 在 JavaScript 中 构 建 一个 主 循环 <br>
<hr>
(src)="31"> JavaScript は イベント と コール バック 関数 に対して 最高 の 働き を し ます 。 <br>
(trg)="28"> JavaScript 能 很好 的 处理 事件 和 回 调 函数 。 <br>
<hr>
(src)="32"> モダン な ブラウザー は できるだけ メソッド を ちょうど それら が 必要 に な っ た 時 や アイドル 状態 の ( もしくは ほか の タスク を や って いる ) 時に 呼 び 出 そう と し ます 。 <br>
(trg)="29"> 现代 浏览 器 努力 在 需要 的 时候 调 用 方法 ， 并 在 间隙 中 闲下来 （ 或 做 其他 任务 ） 。 <br>
<hr>
(src)="33"> それ が どう 素晴らしい アイデア な の か という と 、 あなた の コード を 的確 な 瞬間 に アタッチ できる から です 。 <br>
(trg)="30"> 将 你的 代码 附加 到 适合 它们 的 时刻 是 一个 很好 的 主意 。 <br>
<hr>
(src)="34"> こんな 場合 を 考え て み ま しょう - あなた の 関数 が 毎 フレーム ごと に 厳密 な 間隔 で 絶対に 呼 び 出 さ れ な け れ ば なら ない か 、 もしくは ほか の 何 か が 起 こ って はじめて 絶対に 呼 び 出 さ れ な け れ ば なら ない と し ます 。 <br>
(trg)="31"> 考虑 一下 你的 函数 是 需要 在 严格 的 时间 周期 内 ， 还是 每一 帧 ， 或者 仅仅 是在 发生 了 其他 情况 之后 执行 。 <br>
<hr>
(src)="35"> ブラウザー に いつ 関数 が 呼 び 出 さ れる か について より はっきり させる という こと は ブラウザー が それ を いつ 呼び出す か を 最適 化 する こと を 許す ことに なり ます 。 <br>
(trg)="32"> 当 你的 函数 需要 被 调 用 时 ， 要 更 具体 地 使用 浏览 器 ， 这样 浏览 器 就 可以 在 调 用 时 进行 优 化 。 <br>
<hr>
(src)="36"> また 、 それ は ひょっとしたら あなた の 仕事 を より 簡単 に する かも し れ ま せん 。 <br>
(trg)="33"> 而且 ， 这 可能 会 让 你的 工作 更 轻松 。 <br>
<hr>
(src)="37"> いくつか の コード は フレーム 毎 に 実行 さ れる 必要 が ある かも し れ ま せん ので 、 なぜ その 関数 を ブラウザー の 再 描画 スケジュール 以外 の もの に アタッチ する 必要 が ある ので しょう か ? <br>
(trg)="34"> 有些 代码 需要 逐 帧 运行 ， 所以 应 将 其 附加 到 浏览 器 的 重 绘 周期 中 ， 没有 比 这 更好 的 了 ！ <br>
<hr>
(src)="38"> ウェブでは 、 { { domxref ( " window.requestAnimationFrame ( ) " ) } } が ほとんど の よく プログラミング さ れ た 毎 フレーム メイン ループ の 基礎 に なる で しょう 。 <br>
(trg)="35"> 在 Web 中 ， 通常 { { domxref ( “ window.requestAnimationFrame ( ) ” ) } } 方法 是 大 多数 良好 的 逐 帧 循环 的 基础 。 <br>
<hr>
(src)="40"> その コール バック 関数 は 次 の 再 描画 まで の 適切 な 時間 で 実行 さ れ ます 。 <br>
(trg)="36"> 在 调 用 该 方法 时 必须 传 入 一个 回 调 函数 ， 这个 回 调 函数 将 在 下 一次 重新 绘制 之前 执行 。 <br>
<hr>
(src)="41"> 単純 な メイン ループ の 例 を 見 て み ま しょう 。 <br>
(trg)="37"> 下面 是 一个 简单 的 主 循环 的 例子 ： <br>
<hr>
(src)="42"> window.main = function ( ) { <br>
(trg)="38"> window . main = ( ) = &gt; { <br>
<hr>
(src)="43"> window.requestAnimationFrame ( main ) ; <br>
(trg)="39"> window . requestAnimationFrame ( main ) ; <br>
<hr>
(src)="44"> / / あなた の メイン ループ が 必要 な 事 なんでも <br>
(trg)="40"> / / 无论 你的 主 循环 需要 做 什么 <br>
<hr>
(src)="45"> } ; <br>
(trg)="41"> } ; <br>
<hr>
(src)="46"> main ( ) ; / / メイン ループ 開始 <br>
(trg)="42"> main ( ) ; / / 开始 循环 <br>
<hr>
(src)="47"> メモ : ここで議論されている main ( ) 関数はそれぞれ 、 ループコンテンツを行う前に新しい requestAnimationFrame を スケジュール し てい ます 。 <br>
(trg)="43"> 备注 ： 在这里讨论的每个 main ( ) 方法中 ， 在执行循环内容之前 ， 我们会递归调用一个新的 requestAnimationFrame ， 这 不是 随意 的 ， 它 被 认为 是 最佳 实践 。 <br>
<hr>
(src)="48"> これ は 間 違 って いる の では ありま せん し 、 ベスト プ ラ ク テ ィ ス を 考慮 し てい ます 。 <br>
(src)="49"> 前もって次の requestAnimationFrame を 呼び出す こと は ブラウザー が 適宜 それ を 正しい 時に 受け取る こと を 保証 し ます 。 <br>
(trg)="44"> 如果你的当前帧错过了它的垂直同步窗口的周期 ， 你也在下一个帧通过 requestAnimationFrame 尽早的调用 main ( ) ， 从而 确保 浏览 器 能够 及时 地 执行 。 <br>
<hr>
(src)="51"> 上の コード は 2 つ の 宣言 が あり ます 。 <br>
(trg)="45"> 上面 的 代码 块 有 两 个 语 句 。 <br>
<hr>
(src)="71"> * セミコロン で 始める という の は 以下 の 例 では automatic semicolon insertion ( ASI ) によります 。 <br>
(trg)="46"> 第一个语句创建一个名为 main ( ) 中的 全局 变量 的 函数 。 <br>
<hr>
(src)="76"> ; ( function ( ) { <br>
(src)="77"> function main ( ) { <br>
(src)="78"> window.requestAnimationFrame ( main ) ; <br>
(src)="79"> / / メイン ループ の 中身 <br>
(src)="80"> } <br>
(src)="81"> main ( ) ; / / ループ を 開始 する <br>
(src)="82"> } ) ( ) ; <br>
(trg)="47"> 这个函数做一些工作 ， 也告诉浏览器在下一帧通过 window.requestAnimationFrame ( ) 调 用 本身 。 <br>
<hr>
(src)="98"> ; ( function ( ) { <br>
(src)="99"> function main ( ) { <br>
(src)="100"> MyGame.stopMain = window.requestAnimationFrame ( main ) ; <br>
(trg)="48"> 第二个语句调用第一个语句中定义的 main ( ) 函数 。 <br>
<hr>
</body>
</html>
